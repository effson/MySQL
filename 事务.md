# 四大特性
## 1. A — Atomicity（原子性）
### 含义
- 事务是数据库操作的最小单元，要么全部成功，要么全部失败回滚，不允许只完成一部分
- 如果事务中途失败（断电、异常、SQL 错误），已经执行的修改必须撤销到事务开始前的状态
### 作用
- 保证业务逻辑的完整执行，例如转账时，A 账户扣款和 B 账户加款必须同时成功或同时失败
### InnoDB 实现方式
Undo Log（回滚日志）：
- 在修改数据前，先把被修改的数据的旧值记录到 Undo Log 中
- 事务回滚时，按 Undo Log 把数据恢复到修改前的状态<br>

回滚可以是显式（ROLLBACK）或隐式（事务失败/崩溃恢复时自动执行）

## 2. C — Consistency（一致性）
### 含义 
- 事务执行前后，数据库必须从一个一致状态转变到另一个一致状态
- 一致性不仅指单表数据约束（比如唯一性、外键、检查约束），还包括业务逻辑层面的完整性规则
### 作用
- 保证数据的正确性，不会出现违反约束或逻辑错误的数据状态
### InnoDB 实现方式
- 依赖 原子性、隔离性、持久性共同保证
- 约束与触发器：在执行事务时即刻检查并阻止违规数据写入
- 外部应用逻辑配合，确保业务规则正确实现

## 3. I — Isolation（隔离性）
### 含义
- 多个事务并发执行时，一个事务的中间状态对其他事务是不可见的
- 不同隔离级别决定了事务之间可见性的强弱，防止脏读、不可重复读、幻读等问题
### SQL 标准隔离级别（从低到高）
对于所有的隔离级别,写操作都是加锁的
#### 1. READ UNCOMMITTED（读未提交）
- 可能出现脏读（读到未提交的数据）

#### 2. READ COMMITTED（读已提交）
- 每次读都只能读到其他事务已经提交的数据（Oracle 默认）

#### 3. REPEATABLE READ（可重复读）
- 同一事务中多次读取同一行结果一致（InnoDB 默认，还额外解决了幻读）

#### 4. SERIALIZABLE（可串行化）
- 强制事务串行执行，完全避免并发冲突，但性能最差

## 4. D — Durability（持久性）
### 含义
- 一旦事务提交，其结果就必须被永久保存，即使系统宕机或掉电也不能丢失
### 作用
- 保障数据的最终安全性，使提交后的数据可恢复
### InnoDB 实现方式
Redo Log（重做日志）：
- 在事务提交前，把变更以物理日志形式顺序写入 redo log 并 fsync 落盘
- 宕机后，重启时用 redo log 重放最近提交的事务，恢复到最新状态<br>

Doublewrite Buffer：
- 防止页半写导致 redo 无法正确应用<br>

持久化策略参数：
- innodb_flush_log_at_trx_commit=1（最安全，每次提交都 fsync redo log）
- sync_binlog=1（每次提交都 fsync binlog，主从复制安全）


# 不同的隔离级别并发异常
## 1. 脏读（Dirty Read）
### 1.1 现象
读到别的事务还没提交的数据
### 1.2 出现的隔离级别
只会出现在<mark>读未提交READ UNCOMMITTED</mark>隔离级别
## 2. 不可重复读（Non-Repeatable Read）
### 2.1 现象
同一事务内两次读同一行，结果不同（因为别的事务提交了对该行的修改/删除）
### 2.2 出现的隔离级别
会出现在<mark>读未提交READ UNCOMMITTED和读已提交 READ COMMITTED</mark>隔离级别
## 3. 幻读（Phantom Read）
### 3.1 现象
同一事务内按某个条件读出一批行，后续再读同一范围内的记录多了或少了行（因为别的事务插入/删除了“新行”满足该条件）<br>
也就是当前读和快照读的不一致
### 3.2 出现的隔离级别
会出现在<mark>读未提交READ UNCOMMITTED和读已提交 READ COMMITTED</mark>隔离级别,对于<mark>可重复读REPEATABLE READ</mark>, 在事务开始时锁定读 FOR UPDATE/SHARE或 LOCK IN SHARE MODE可以避免幻读

# MVCC多版本并发控制
## 1. Read View（读视图）
### m_ids
